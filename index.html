// App.js - Main GoBalance Bridge App
import React, { useState, useEffect } from 'react';
import {
  StyleSheet,
  View,
  Text,
  TouchableOpacity,
  ScrollView,
  StatusBar,
  Alert,
} from 'react-native';
import { BleManager } from 'react-native-ble-plx';

// WebSocket Server - Install: npm install react-native-tcp-socket
import TcpSocket from 'react-native-tcp-socket';

const App = () => {
  const [bleManager] = useState(() => new BleManager());
  const [device, setDevice] = useState(null);
  const [connected, setConnected] = useState(false);
  const [serverRunning, setServerRunning] = useState(false);
  const [clients, setClients] = useState([]);
  const [sensorData, setSensorData] = useState({ tiltX: 0, tiltY: 0 });
  const [logs, setLogs] = useState([]);
  const [ipAddress, setIpAddress] = useState('Detecting...');

  // WebSocket server
  let server = null;
  const connectedClients = [];

  const addLog = (message, type = 'info') => {
    const timestamp = new Date().toLocaleTimeString();
    setLogs(prev => [{
      id: Date.now(),
      message,
      type,
      timestamp
    }, ...prev.slice(0, 50)]);
  };

  // Get IP Address
  useEffect(() => {
    const getIPAddress = async () => {
      try {
        // Install: npm install react-native-network-info
        const NetworkInfo = require('react-native-network-info');
        const ip = await NetworkInfo.getIPV4Address();
        setIpAddress(ip || 'Unable to detect');
      } catch (error) {
        setIpAddress('Install react-native-network-info');
      }
    };
    getIPAddress();
  }, []);

  // Start WebSocket Server
  const startServer = () => {
    try {
      server = TcpSocket.createServer((socket) => {
        addLog('Client connected!', 'success');
        connectedClients.push(socket);
        setClients(prev => [...prev, socket]);

        // Handle WebSocket handshake
        socket.on('data', (data) => {
          const message = data.toString();
          
          // Simple WebSocket handshake
          if (message.includes('Upgrade: websocket')) {
            const key = message.match(/Sec-WebSocket-Key: (.+)/)?.[1]?.trim();
            if (key) {
              const crypto = require('crypto');
              const accept = crypto
                .createHash('sha1')
                .update(key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11')
                .digest('base64');
              
              const response = [
                'HTTP/1.1 101 Switching Protocols',
                'Upgrade: websocket',
                'Connection: Upgrade',
                `Sec-WebSocket-Accept: ${accept}`,
                '',
                ''
              ].join('\r\n');
              
              socket.write(response);
              addLog('WebSocket handshake completed', 'success');
            }
          }
        });

        socket.on('close', () => {
          addLog('Client disconnected', 'info');
          const index = connectedClients.indexOf(socket);
          if (index > -1) connectedClients.splice(index, 1);
          setClients(connectedClients);
        });

        socket.on('error', (error) => {
          addLog(`Socket error: ${error.message}`, 'error');
        });
      }).listen({ port: 8080, host: '0.0.0.0' });

      server.on('error', (error) => {
        addLog(`Server error: ${error.message}`, 'error');
        setServerRunning(false);
      });

      setServerRunning(true);
      addLog('WebSocket server started on port 8080', 'success');
    } catch (error) {
      addLog(`Failed to start server: ${error.message}`, 'error');
    }
  };

  // Send data to all connected clients
  const broadcastSensorData = (tiltX, tiltY) => {
    const data = JSON.stringify({
      type: 'sensor',
      tiltX,
      tiltY,
      timestamp: Date.now()
    });

    // WebSocket frame format (simple text frame)
    const frame = Buffer.alloc(data.length + 2);
    frame[0] = 0x81; // FIN + Text frame
    frame[1] = data.length; // Payload length
    frame.write(data, 2);

    connectedClients.forEach(client => {
      try {
        client.write(frame);
      } catch (error) {
        console.error('Error sending to client:', error);
      }
    });
  };

  // Scan for GoBalance device
  const scanForDevice = async () => {
    try {
      addLog('Scanning for GoBalance board...', 'info');
      
      // Request permissions first (Android)
      const granted = await bleManager.requestPermissions();
      if (!granted) {
        Alert.alert('Error', 'Bluetooth permissions required');
        return;
      }

      bleManager.startDeviceScan(null, null, (error, scannedDevice) => {
        if (error) {
          addLog(`Scan error: ${error.message}`, 'error');
          return;
        }

        // Look for GoBalance device
        if (scannedDevice?.name?.includes('GoBalance')) {
          addLog(`Found: ${scannedDevice.name}`, 'success');
          bleManager.stopDeviceScan();
          setDevice(scannedDevice);
        }
      });

      // Stop scan after 10 seconds
      setTimeout(() => {
        bleManager.stopDeviceScan();
        if (!device) {
          addLog('No GoBalance device found', 'error');
        }
      }, 10000);

    } catch (error) {
      addLog(`Error: ${error.message}`, 'error');
    }
  };

  // Connect to device
  const connectToDevice = async () => {
    if (!device) return;

    try {
      addLog(`Connecting to ${device.name}...`, 'info');
      
      const connectedDevice = await device.connect();
      await connectedDevice.discoverAllServicesAndCharacteristics();
      
      setConnected(true);
      addLog('Connected! Discovering services...', 'success');

      // Get all services
      const services = await connectedDevice.services();
      addLog(`Found ${services.length} services`, 'info');

      // Subscribe to all notify characteristics
      for (const service of services) {
        const characteristics = await service.characteristics();
        
        for (const char of characteristics) {
          if (char.isNotifiable) {
            try {
              await char.monitor((error, characteristic) => {
                if (error) {
                  addLog(`Monitor error: ${error.message}`, 'error');
                  return;
                }

                const value = characteristic.value;
                if (value) {
                  // Decode base64 to bytes
                  const bytes = Buffer.from(value, 'base64');
                  
                  // Parse sensor data (adjust this based on actual format)
                  if (bytes.length >= 4) {
                    // Assume 2 bytes per axis as signed int16 little-endian
                    let tiltX = bytes.readInt16LE(0);
                    let tiltY = bytes.readInt16LE(2);
                    
                    // Scale to degrees (-45 to +45)
                    tiltX = (tiltX / 1000) * 45;
                    tiltY = (tiltY / 1000) * 45;
                    
                    // Clamp values
                    tiltX = Math.max(-45, Math.min(45, tiltX));
                    tiltY = Math.max(-45, Math.min(45, tiltY));
                    
                    setSensorData({ tiltX, tiltY });
                    
                    // Broadcast to web game
                    broadcastSensorData(tiltX, tiltY);
                  }
                }
              });
              
              addLog(`Subscribed to ${char.uuid.slice(0, 8)}...`, 'success');
            } catch (e) {
              // Not all characteristics can be monitored
            }
          }
        }
      }

    } catch (error) {
      addLog(`Connection error: ${error.message}`, 'error');
      setConnected(false);
    }
  };

  // Disconnect
  const disconnect = async () => {
    if (device && connected) {
      try {
        await device.cancelConnection();
        setConnected(false);
        setDevice(null);
        addLog('Disconnected from board', 'info');
      } catch (error) {
        addLog(`Disconnect error: ${error.message}`, 'error');
      }
    }
  };

  return (
    <View style={styles.container}>
      <StatusBar barStyle="light-content" />
      
      {/* Header */}
      <View style={styles.header}>
        <Text style={styles.title}>GoBalance Bridge</Text>
        <Text style={styles.subtitle}>Connect board & stream to web game</Text>
      </View>

      <ScrollView style={styles.content}>
        {/* Server Status */}
        <View style={styles.card}>
          <Text style={styles.cardTitle}>WebSocket Server</Text>
          <View style={styles.statusRow}>
            <Text style={styles.label}>Status:</Text>
            <Text style={[styles.badge, serverRunning ? styles.badgeSuccess : styles.badgeDanger]}>
              {serverRunning ? 'Running' : 'Stopped'}
            </Text>
          </View>
          <View style={styles.statusRow}>
            <Text style={styles.label}>IP Address:</Text>
            <Text style={styles.value}>{ipAddress}</Text>
          </View>
          <View style={styles.statusRow}>
            <Text style={styles.label}>Port:</Text>
            <Text style={styles.value}>8080</Text>
          </View>
          <View style={styles.statusRow}>
            <Text style={styles.label}>Clients:</Text>
            <Text style={styles.value}>{clients.length}</Text>
          </View>
          
          {!serverRunning && (
            <TouchableOpacity style={styles.btnPrimary} onPress={startServer}>
              <Text style={styles.btnText}>Start Server</Text>
            </TouchableOpacity>
          )}
        </View>

        {/* GoBalance Connection */}
        <View style={styles.card}>
          <Text style={styles.cardTitle}>GoBalance Board</Text>
          <View style={styles.statusRow}>
            <Text style={styles.label}>Status:</Text>
            <Text style={[styles.badge, connected ? styles.badgeSuccess : styles.badgeDanger]}>
              {connected ? 'Connected' : 'Disconnected'}
            </Text>
          </View>
          {device && (
            <View style={styles.statusRow}>
              <Text style={styles.label}>Device:</Text>
              <Text style={styles.value}>{device.name}</Text>
            </View>
          )}
          
          {!connected ? (
            <>
              {!device ? (
                <TouchableOpacity style={styles.btnPrimary} onPress={scanForDevice}>
                  <Text style={styles.btnText}>Scan for Board</Text>
                </TouchableOpacity>
              ) : (
                <TouchableOpacity style={styles.btnSuccess} onPress={connectToDevice}>
                  <Text style={styles.btnText}>Connect to {device.name}</Text>
                </TouchableOpacity>
              )}
            </>
          ) : (
            <TouchableOpacity style={styles.btnDanger} onPress={disconnect}>
              <Text style={styles.btnText}>Disconnect</Text>
            </TouchableOpacity>
          )}
        </View>

        {/* Sensor Data */}
        <View style={styles.card}>
          <Text style={styles.cardTitle}>Live Sensor Data</Text>
          <View style={styles.sensorRow}>
            <Text style={styles.sensorLabel}>Tilt X:</Text>
            <Text style={styles.sensorValue}>{sensorData.tiltX.toFixed(1)}°</Text>
          </View>
          <View style={styles.sensorRow}>
            <Text style={styles.sensorLabel}>Tilt Y:</Text>
            <Text style={styles.sensorValue}>{sensorData.tiltY.toFixed(1)}°</Text>
          </View>
        </View>

        {/* Logs */}
        <View style={styles.card}>
          <Text style={styles.cardTitle}>Activity Log</Text>
          <View style={styles.logContainer}>
            {logs.map(log => (
              <Text key={log.id} style={[styles.logEntry, styles[`log${log.type.charAt(0).toUpperCase() + log.type.slice(1)}`]]}>
                [{log.timestamp}] {log.message}
              </Text>
            ))}
          </View>
        </View>
      </ScrollView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#1e3c72',
  },
  header: {
    padding: 20,
    paddingTop: 50,
    backgroundColor: '#2a5298',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: 'white',
  },
  subtitle: {
    fontSize: 14,
    color: '#e0e0e0',
    marginTop: 5,
  },
  content: {
    flex: 1,
    padding: 15,
  },
  card: {
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 20,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 15,
    color: '#333',
  },
  statusRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingVertical: 8,
  },
  label: {
    fontSize: 14,
    fontWeight: '600',
    color: '#666',
  },
  value: {
    fontSize: 14,
    color: '#333',
  },
  badge: {
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 12,
    fontSize: 12,
    fontWeight: '600',
  },
  badgeSuccess: {
    backgroundColor: '#c6f6d5',
    color: '#22543d',
  },
  badgeDanger: {
    backgroundColor: '#fed7d7',
    color: '#742a2a',
  },
  btnPrimary: {
    backgroundColor: '#667eea',
    padding: 15,
    borderRadius: 8,
    marginTop: 15,
  },
  btnSuccess: {
    backgroundColor: '#48bb78',
    padding: 15,
    borderRadius: 8,
    marginTop: 15,
  },
  btnDanger: {
    backgroundColor: '#f56565',
    padding: 15,
    borderRadius: 8,
    marginTop: 15,
  },
  btnText: {
    color: 'white',
    textAlign: 'center',
    fontSize: 16,
    fontWeight: '600',
  },
  sensorRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  sensorLabel: {
    fontSize: 16,
    fontWeight: '600',
    color: '#666',
  },
  sensorValue: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#667eea',
  },
  logContainer: {
    backgroundColor: '#1a202c',
    padding: 15,
    borderRadius: 8,
    maxHeight: 200,
  },
  logEntry: {
    fontSize: 12,
    marginBottom: 5,
    fontFamily: 'monospace',
  },
  logInfo: {
    color: '#90cdf4',
  },
  logSuccess: {
    color: '#68d391',
  },
  logError: {
    color: '#fc8181',
  },
});

export default App;
